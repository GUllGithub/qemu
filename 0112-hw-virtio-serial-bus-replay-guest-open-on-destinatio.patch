commit c8c087ff8d57632c93c8ca9492a32b045eec2065
Author: Miroslav Rezanina <mrezanin@redhat.com>
Date:   Mon Mar 4 09:17:44 2013 +0100

    hw/virtio-serial-bus: replay guest open on destination
    
    Message-Id: <1f54fab0e8f692986254b69c607f4151d9743260.1354903384.git.crobinso@redhat.com>
    
    This is rewrite of a patch carried in Fedora previously based
    on new code upstream, here is the original message, it still applies:
    (the original fedora patch was commit id
    a9bc20afc1f0604ee81c23b7c67d627e51d2e8d4, this is useful for grepping in
    logs, it isn't in upstream)
    
    When migrating a host with with a spice agent running the mouse becomes
    non operational after the migration. This is rhbz #725965.
    
    The problem is that after migration spice doesn't know the guest agent
    is open.  Spice is just a char dev here. And a chardev cannot query it's
    device, the device has to let the chardev know when it is open. Right
    now after migration the chardev which is recreated is in it's default
    state, which assumes the guest is disconnected.
    
    Char devices carry no information across migration, but the
    virtio-serial does already carry the guest_connected state. This patch
    passes that bit to the chardev.
    
    Signed-off-by: Alon Levy <alevy@redhat.com>

diff --git a/hw/virtio-serial-bus.c b/hw/virtio-serial-bus.c
index aa7d0d7..5078129 100644
--- a/hw/virtio-serial-bus.c
+++ b/hw/virtio-serial-bus.c
@@ -642,6 +642,7 @@ static void virtio_serial_post_load_timer_cb(void *opaque)
     VirtIOSerial *s = opaque;
     VirtIOSerialPort *port;
     uint8_t host_connected;
+    VirtIOSerialPortClass *vsc;
 
     if (!s->post_load) {
         return;
@@ -657,6 +658,11 @@ static void virtio_serial_post_load_timer_cb(void *opaque)
             send_control_event(s, port->id, VIRTIO_CONSOLE_PORT_OPEN,
                                port->host_connected);
         }
+        vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);
+        if (port->guest_connected && vsc->guest_open) {
+            /* replay guest open */
+            vsc->guest_open(port);
+        }
     }
     g_free(s->post_load->connected);
     qemu_free_timer(s->post_load->timer);
